const ChaningCanvas=((b,c)=>{function d(a){return a in j}function e(a){return null!=a&&(Array.isArray(a)||"number"==typeof a.length&&-1<a.length)}function f(a){return a+(["st","nd"][a%10-1]||"th")}function g(a){return a instanceof window.HTMLElement}const h=c.createElement("canvas"),j=h.getContext("2d"),k="Failed to execute",l=a=>new TypeError(a);return class a{constructor(a){this.element=a,this.ctx=a.getContext("2d"),this.path=[]}static create(b){const d=c.createElement("canvas");return b={width:300,height:300,...Object(b)},Object.assign(d,b),new a(d)}static prepareStyle(a){for(let b in a)d(b)||console.warn(`Can't find ${b} is valid style key.`);return a}appendInto(a){if(!g(a))throw l(`${k} 'appendInto': parameter 1 is not of type 'HTMLElement'.`);return a.appendChild(this.element),this}set(a){return Object.assign(this.ctx,Object(a)),this}execute(a,b){const c=this.ctx;return c.save(),this.set(a),b(this),c.restore(),this}clear(a,b){const c=this.element;return a=a||c.width,b=b||c.height,this.ctx.clearRect(0,0,a,b),this}closePath(){return this.ctx.closePath(),this}addPath(...a){const b=this.ctx,c=`${k} 'addPath':`;return a=a.map((a,b)=>{if(!e(a))throw l(`${c} ${f(b)} element of path is not of type 'Array'.`);if(a=Array.from(a),2>a.length)throw l(`${c} 2 element required, but only ${a.length} included in ${f(b)} element of path.`);return Array.from(a)}),this.path.push(...a.map(a=>({type:"point",point:a}))),this}fill(a,b,c){const d=this.element,e=this.ctx;return a=a||e.fillStyle,b=b||d.width,c=c||d.height,this.execute({fillStyle:a},()=>{e.fillRect(0,0,b,c)})}stroke(a){const b=this.ctx;return this.path.forEach((a,c)=>{switch(a.type){case"point":b[`${c?"line":"move"}To`](...a.point);break;default:throw this.path.length=0,l(`${`${k} 'stroke':`} ${f(i)} element of path data is Unkwon path type.`);}}),this.execute(a,()=>b.stroke())}}})(this,document);
