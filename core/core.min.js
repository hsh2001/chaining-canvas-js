const ChaningCanvas=((a,b)=>{function c(a){return a in h}function d(a){return null!=a&&(Array.isArray(a)||"number"==typeof a.length&&-1<a.length)}function e(a){return a+(["st","nd"][a%10-1]||"th")}function f(a){return a instanceof window.HTMLElement}const g=b.createElement("canvas"),h=g.getContext("2d"),j="Failed to execute";return class a{constructor(a){this.element=a,this.ctx=a.getContext("2d"),this.path=[]}static create(c){const d=b.createElement("canvas");return c={width:300,height:300,...Object(c)},Object.assign(d,c),new a(d)}static prepareStyle(a){for(let b in a)c(b)||console.warn(`Can't find ${b} is valid style key.`);return a}appendInto(a){if(!f(a))throw new TypeError(`${j} 'appendInto': parameter 1 is not of type 'HTMLElement'.`);return a.appendChild(this.element),this}set(a){return Object.assign(this.ctx,Object(a)),this}execute(a,b){const c=this.ctx;return c.save(),this.set(a),b(this),c.restore(),this}clear(a,b){const c=this.element;return a=a||c.width,b=b||c.height,this.ctx.clearRect(0,0,a,b),this}closePath(){return this.ctx.closePath(),this}addPath(...a){const b=this.ctx,c=`${j} 'addPath':`;return a=a.map((a,b)=>{if(!d(a))throw new TypeError(`${c} ${e(b)} element of path is not of type 'Array'.`);if(a=Array.from(a),2>a.length)throw new TypeError(`${c} 2 element required, but only ${a.length} included in ${e(b)} element of path.`);return Array.from(a)}),this.path.push(...a.map(a=>({type:"point",point:a}))),this}fill(a,b,c){const d=this.element,e=this.ctx;return a=a||e.fillStyle,b=b||d.width,c=c||d.height,this.execute({fillStyle:a},()=>{e.fillRect(0,0,b,c)})}stroke(a){const b=this.ctx;return this.path.forEach((a,c)=>{switch(a.type){case"point":b[`${c?"line":"move"}To`](...a.point);break;default:throw this.path.length=0,new Error(`${`${j} 'stroke':`} ${e(i)} element of path data is Unkwon path type.`);}}),this.execute(a,()=>b.stroke())}}})(this,document);
