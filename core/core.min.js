const ChaningCanvas=((a,b,c)=>{const d=Math.PI,e=b.createElement("canvas"),f=e.getContext("2d"),g="Failed to execute",h=["Image","CSSImageValue","HTMLImageElement","SVGImageElement","HTMLVideoElement","HTMLCanvasElement","ImageBitmap","OffscreenCanvas"],j={},k=[["moveTo",2],["point",2],["arc",6],["bezierCurveTo",6],["quadraticCurveTo",4],["ellipse",8]];k.forEach(([a,b])=>{j[a]=(...c)=>({type:a,params:n(c,b)})}),j.lineTo=j.point,j.circle=(a,b,c)=>([a,b,c]=[a,b,c].map(m),[j.moveTo(a+c,b),j.arc(a,b,c,0,2*d)]),j.deg=a=>180*a/d;const l=a=>a in f,m=a=>+a||0,n=(a,b,d)=>a.concat(c(b).fill()).slice(0,b).map(d||m),o=a=>"string"==typeof a||a instanceof CanvasGradient,p=b=>b&&h.some(c=>b instanceof a[c]),q=a=>a&&(c.isArray(a)||"number"==typeof a.length&&-1<a.length),r=a=>a+(["st","nd"][a%10-1]||"th"),s=b=>b instanceof a.HTMLElement,t=(a,b,c)=>`${a} parameter ${b} is not of type '${c}'.`,u=(a,b)=>{const c=a.ctx;return a.path.forEach((d,e)=>{const f=d.type;for(let a=0;a<k.length;a++){const b=k[a][0];if(f===b&&c[f])return c[f](...d.params)}switch(f){case"point":c[`${e?"line":"move"}To`](...d.params);break;default:throw a.path.length=0,new TypeError(`${b} ${r(i)} element of path data is Unkwon path type.`);}}),a};return class a{constructor(a){this.element=a,this.ctx=a.getContext("2d"),this.path=[]}static create(c){const d=b.createElement("canvas");return c={width:300,height:300,...Object(c)},Object.assign(d,c),new a(d)}static prepareStyle(a){for(let b in a)l(b)||console.warn(`Can't find ${b} is valid style key.`);return a}appendInto(a){if(!s(a))throw new TypeError(t(`${g} 'appendInto':`,1,"HTMLElement"));return a.appendChild(this.element),this}toImg(...a){return this.toImage(...a)}toImage(a,b){const c=this.element,d=new Image,e=new Promise((b,e)=>{d.src=c.toDataURL(a||"image/png"),d.onload=()=>b(d),d.onerror=e});return"function"==typeof b?(e.then(a=>b(a,null)).catch(a=>b(null,a)),this):e}getImgData(...a){return this.getImageData(...a)}getImageData(a,b,c,d){const e=[a,b,c,d].map(m);return this.ctx.getImageData(...e).data}getPixelData(...a){return this.getPixel(...a)}getPixel(c,d){const[e,f,g,b]=this.ctx.getImageData(...[c,d].map(m),1,1).data;return{r:e,g:f,b:g,a:b}}set(a){return a={...Object(a)},["lineDash","transform","scale"].forEach(b=>{b in a&&(this[b]=a[b],delete a[b])}),Object.assign(this.ctx,a),this}set lineDash(a){return this.ctx.setLineDash(a)}get lineDash(){return this.ctx.getLineDash()}set transform(a){return this.ctx.setTransform(...(q(a)?c.from(a):[a]))}get transform(){return this.ctx.getTransform()}set scale([a,b]){return this._scale=[a,b],this.ctx.scale(a,b),[a,b]}get scale(){return this._scale||[1,1]}execute(a,b){const c=this.ctx;return c.save(),this.set(a),b(this),c.restore(),this}drawImg(...a){return this.drawImage(...a)}drawImage(a,b,c,...d){if(!p(a)){const a=h.join(" or ");throw new TypeError(t(`${g} 'drawImage':`,1,a))}return b=+b||0,c=+c||0,this.ctx.drawImage(a,b,c,...d),this}clear(a,b){const c=this.element;return a=a||c.width,b=b||c.height,this.ctx.clearRect(0,0,a,b),this}clip(...a){return this.ctx.clip(...a),this}resetPath(...a){return this.closePath(...a)}closePath(){return this.ctx.closePath(),this.path.length=0,this}addPath(a){const b=this.ctx,d=`${g} 'addPath':`;let e;if("function"!=typeof a)throw new TypeError(t(d,1,"Function"));if(e=a(j),!q(e))throw new TypeError(`${d} callback function must return value, which is type of Array.`);return e=c.from(e).flat(1/0),e.forEach((a,b)=>{if(!a||!a.type)throw new TypeError(`${d} ${r(b)} element of path data is Unkwon path type.`)}),this.path.push(...e),this}setPath(a){return this.closePath().addPath(a)}fill(a,b,c,d,e){const f=this.element,h=this.ctx;return(a=o(a)?{fillStyle:a}:{},[0,1].includes(arguments.length)&&this.path.length)?u(this,`${g} 'fill':`).execute(a,()=>h.fill()):(b=b||0,c=c||0,d=null==d?f.width:d,e=null==e?f.height:e,this.execute(a,()=>h.fillRect(b,c,d,e)))}stroke(a){return u(this,`${g} 'stroke':`).execute(a,a=>a.ctx.stroke())}}})(this,document,Array);
