const ChaningCanvas=((a,b)=>{function c(a){return a in n}function d(a){return+a||0}function e(a,b,c){return a.concat(Array(b).fill()).slice(0,b).map(c||d)}function f(a){return"string"==typeof a||a instanceof CanvasGradient}function g(a){return a&&q.some(b=>a instanceof window[b])}function h(a){return null!=a&&(Array.isArray(a)||"number"==typeof a.length&&-1<a.length)}function j(a){return a+(["st","nd"][a%10-1]||"th")}function k(a){return a instanceof window.HTMLElement}function l(a,b){const c=a.ctx;return a.path.forEach((d,e)=>{switch(d.type){case"moveTo":c.moveTo(...d.params);break;case"point":c[`${e?"line":"move"}To`](...d.params);break;case"arc":c.arc(...d.params);break;case"bezierCurve":c.bezierCurveTo(...d.params);break;case"ellipse":c.ellipse(...d.params);break;default:throw a.path.length=0,new TypeError(`${b} ${j(i)} element of path data is Unkwon path type.`);}}),a}const m=b.createElement("canvas"),n=m.getContext("2d"),o="Failed to execute",p={},q=["Image","CSSImageValue","HTMLImageElement","SVGImageElement","HTMLVideoElement","HTMLCanvasElement","ImageBitmap","OffscreenCanvas"];return[["moveTo",2],["point",2],["arc",6],["bezierCurve",6],["ellipse",8]].forEach(([a,b])=>{p[a]=function(...c){return{type:a,params:e(c,b)}}}),p.lineTo=p.point,p.circle=function(a,b,c){return params=e([a,b,c],3),params.push(0,6.283185307),[p.moveTo(a+c,b),p.arc(...params)]},class a{constructor(a){this.element=a,this.ctx=a.getContext("2d"),this.path=[]}static create(c){const d=b.createElement("canvas");return c={width:300,height:300,...Object(c)},Object.assign(d,c),new a(d)}static prepareStyle(a){for(let b in a)c(b)||console.warn(`Can't find ${b} is valid style key.`);return a}appendInto(a){if(!k(a))throw new TypeError(`${o} 'appendInto': parameter 1 is not of type 'HTMLElement'.`);return a.appendChild(this.element),this}toImg(...a){return this.toImage(...a)}toImage(a){const b=this.element,c=new Image;return new Promise((d,e)=>{c.src=b.toDataURL(a),c.onload=()=>d(c),c.onerror=e})}set(a){return Object.assign(this.ctx,Object(a)),this}execute(a,b){const c=this.ctx;return c.save(),this.set(a),b(this),c.restore(),this}drawImg(...a){return this.drawImage(...a)}drawImage(a,b,c,...d){if(!g(a)){const a=q.join(" or ");throw new TypeError(`${`${o} 'drawImage':`} The provided value is not of type '(${a})'`)}return b=+b||0,c=+c||0,this.ctx.drawImage(a,b,c,...d),this}clear(a,b){const c=this.element;return a=a||c.width,b=b||c.height,this.ctx.clearRect(0,0,a,b),this}closePath(){return this.ctx.closePath(),this.path.length=0,this}addPath(a){const b=this.ctx,c=`${o} 'addPath':`;let d=a(p);if(!h(d))throw new TypeError(`${c} callback function must return value, which is type of Array.`);return d=Array.from(d).flat(1/0),d.forEach((a,b)=>{if(!a||!a.type)throw new TypeError(`${c} ${j(b)} element of path data is Unkwon path type.`)}),this.path.push(...d),this}setPath(a){return this.closePath().addPath(a)}fill(a,b,c,d,e){const g=this.element,h=this.ctx;return(a=f(a)?{fillStyle:a}:{},[0,1].includes(arguments.length)&&this.path.length)?l(this,`${o} 'fill':`).execute(a,()=>h.fill()):(b=b||0,c=c||0,d=null==d?g.width:d,e=null==e?g.height:e,this.execute(a,()=>h.fillRect(b,c,d,e)))}stroke(a){return l(this,`${o} 'stroke':`).execute(a,a=>a.ctx.stroke())}}})(this,document);
